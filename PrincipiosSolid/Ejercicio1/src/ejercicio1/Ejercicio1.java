/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/Classes/Main.java to edit this template
 */
package ejercicio1;

/**
 *
 * @author const
 */
public class Ejercicio1 {

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) {
        /*
        Los 5 principios SOLID de diseño de aplicaciones de software son fundamentales para 
        lograr un código de calidad y un desarrollo eficaz son:


        S – Single Responsibility Principle (SRP)
        O – Open/Closed Principle (OCP)
        L – Liskov Substitution Principle (LSP)
        I – Interface Segregation Principle (ISP)
        D – Dependency Inversion Principle (DIP)


        Al aplicar estos principios, se busca alcanzar diversos objetivos en el desarrollo de software, 
        como crear un software eficaz, flexible ante cambios, reutilizable y fácilmente escalable.
        
        1. El Single Responsibility Principle (SRP) 
        establece que una clase debe tener una única responsabilidad, es decir, una sola razón para cambiar. 
        Esto implica que la clase debe estar enfocada en una sola tarea o funcionalidad, lo que mejora la cohesión
        del código y facilita su mantenimiento.
        
        2. El principio Open/Closed (OCP) 
        establece que las clases deben estar abiertas para su extensión, pero cerradas para su modificación.
        Esto significa que se deben poder agregar nuevas funcionalidades a una clase sin modificar su código existente.
        Para lograr esto, se puede utilizar la herencia o la implementación de nuevas interfaces.
        
        3. El principio de Liskov Substitution (LSP) 
        establece que los objetos de una clase derivada deben poder ser sustituidos 
        por objetos de su clase base sin afectar el correcto funcionamiento del programa. En
        otras palabras, las subclases deben ser capaces de mantener las propiedades y comportamientos de la clase padre.
        
        4.  el Interface Segregation Principle (ISP
        sugiere que se deben crear interfaces que sean específicas
        para un tipo de cliente o una finalidad concreta. En lugar de tener una única interfaz que obligue a las
        clases a implementar muchos métodos que no utilizarán, es preferible contar con muchas interfaces que definan 
        un número reducido de métodos, cada una enfocada en una funcionalidad específica. De esta manera, las clases solo
        implementarán las interfaces que realmente necesiten y evitarán la implementación innecesaria de métodos. El ISP
        promueve la segregación de interfaces para mantener la cohesión y prevenir la dependencia de código innecesario.
        
        5. Dependency Inversion Principle (DIP)
        "Depende de abstracciones, no de clases concretas". Según este principio,
        los módulos de alto nivel no deben depender de los módulos de bajo nivel; 
        ambos deben depender de abstracciones. Además, las abstracciones no deben 
        depender de los detalles, sino que los detalles deben depender de las abstracciones.
        */
    }
    
}
